#!/usr/bin/env ruby
# Import Text records using data from TEI files.

require 'optparse'

puts "Loading environment"
require File.expand_path('../../config/environment',  __FILE__)
require 'import'

# Valid selections for access rights.
# Note: This script doesn't handle the case of lease/embargo.
def visibility_choices
  { 'open' => Hydra::AccessControls::AccessRight::VISIBILITY_TEXT_VALUE_PUBLIC,
    'institution' => Hydra::AccessControls::AccessRight::VISIBILITY_TEXT_VALUE_AUTHENTICATED,
    'private' => Hydra::AccessControls::AccessRight::VISIBILITY_TEXT_VALUE_PRIVATE }
end

# Parse the the command line arguments
def parse_inputs(args)
  inputs = {}
  opts = OptionParser.new
  opts.banner = 'Usage: example.rb [options]'

  opts.on('-p PATH', 'The path to the directory where the TEI files are located. (required)') do |path|
    raise "path is required" unless path
    inputs[:path] = path
  end

  opts.on("-v [VISIBILITY]", "The visibility level that the imported records will have.", "Valid options are: #{visibility_choices.keys.inspect}") do |vis|
    vis = vis.downcase
    inputs[:visibility] = vis

    unless visibility_choices.include?(vis)
      raise "Invalid value for visibility: #{vis}"
    end
  end

  opts.parse!(args)

  # All the arguments should have been read by now.
  # If there are any left, abort the script.
  raise "Can't parse arguments: #{args.inspect}" unless args.empty?

  inputs
rescue => e
  puts e.message
  puts opts
  exit 1
end


# Read and validate inputs
options = parse_inputs(ARGV)

dir = options[:path] # Directory where TEI files are located

# Access rights for the imported records
visibility = visibility_choices.fetch(options[:visibility], 'private')

puts "Import Text records using TEI files in: #{dir}"
puts "Visibility will be: #{visibility}"

puts "Starting import"
importer = Import::TextImporter.new(dir, visibility)
importer.run

puts "Printing import results"

unless importer.skipped_imports.empty?
  puts "\nSkipped Imports:"
  importer.skipped_imports.each { |msg| puts "  #{msg}" }
end

unless importer.warnings.empty?
  puts "\nWarning messages:"
  importer.warnings.each { |msg| puts msg }
end

unless importer.errors.empty?
  puts "\nError messages:"
  importer.errors.each { |msg| puts msg }
end

puts "\nImport finished:"
puts "   Records imported: #{importer.successful_imports.count}"
puts "   Records skipped:  #{importer.skipped_imports.count}"
puts "   Warnings:         #{importer.warnings.count}"
puts "   Errors:           #{importer.errors.count}"

